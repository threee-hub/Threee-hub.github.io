<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘山的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Threee-hub.github.io/"/>
  <updated>2019-11-27T03:41:09.933Z</updated>
  <id>http://Threee-hub.github.io/</id>
  
  <author>
    <name>刘山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一</title>
    <link href="http://Threee-hub.github.io/2019/11/26/%E7%BB%84%E5%8E%9F%E9%94%99%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://Threee-hub.github.io/2019/11/26/组原错题知识点/</id>
    <published>2019-11-26T15:35:58.000Z</published>
    <updated>2019-11-27T03:41:09.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成原理-计算机系统概述-错题解析-知识点-一"><a href="#计算机组成原理-计算机系统概述-错题解析-知识点-一" class="headerlink" title="计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一"></a>计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一</h3><h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><blockquote><ol><li>早期的冯·诺依曼机以<strong>运算器</strong>为中心，而现代计算机以<strong>存储器</strong>为中心。冯·诺依曼机最根本的特征是采用<strong>“存储程序”</strong>原理，基本工作方式是<strong>控制流驱动方式</strong>。</li><li><strong>“存储程序”原理</strong>，是将根据特定问题编写的程序存放在计算机存储器中，然后按存储器中的存储程序的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令，直至程序结束执行。</li></ol></blockquote><blockquote><hr></blockquote><h4 id="错题解析："><a href="#错题解析：" class="headerlink" title="错题解析："></a>错题解析：</h4><p>习题一：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112601.png" alt="题目一"></p><blockquote><ol><li>答案为 C 。</li><li>计算机可以从时间和空间两方面来区分指令和数据。在时间上，<strong>取指周期(取指令)</strong>从内存中取出的是指令，而<strong>执行周期（执行指令）</strong>从内存取出或往内存中写入的是数据；在空间上，从内存中取出指令送<strong>控制器</strong>，而执行周期从内存从取的数据送<strong>运算器</strong>、往内存写入的数据也是来自于运算器。</li></ol></blockquote><blockquote><hr><p>习题二：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112602.png" alt="题目二"></p><ol><li>答案为 C 。</li><li>基本原理：把存储单元所存内容的某一部分作为检索项（即关键字项），去检索该存储器。</li><li>计算机系统中，相联存储器主要用于虚拟存储器中存放段表、页表和快表，以及高速缓冲存储器Cache中存放块地址。这是因为，在这两种应用中，都需要快速查找。</li></ol></blockquote><blockquote><hr></blockquote><p>习题三：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112603.png" alt="题目三"></p><blockquote><ol><li>答案为 C 。</li><li>翻译程序是指把高级语言源程序转换成机器语言程序（目标代码）的软件。主要有两种：一种是<strong>编译程序</strong>，它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无需重新编译。另一种是<strong>解释程序</strong>，它将源程序的一条语句翻译成对应的机器目标代码并立即执行，然后翻译下一条源程序语句并执行，直至全部源程序语句被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</li><li>汇编语言也是一种语言翻译程序，是面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。<br>如C语言编译链接过程：源程序（.C）–（C编译器）–&gt; 汇编源程序 –（汇编程序）–&gt; 目标程序 –（链接程序）–&gt; 可执行程序</li></ol></blockquote><blockquote><hr></blockquote><p>习题四：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112604.png" alt="题目四"></p><blockquote><p>· 答案为 C 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成原理-计算机系统概述-错题解析-知识点-一&quot;&gt;&lt;a href=&quot;#计算机组成原理-计算机系统概述-错题解析-知识点-一&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一&quot;&gt;&lt;/a&gt;计算机组
      
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://Threee-hub.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令</title>
    <link href="http://Threee-hub.github.io/2019/11/26/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://Threee-hub.github.io/2019/11/26/linux常用命令/</id>
    <published>2019-11-26T15:35:58.000Z</published>
    <updated>2019-12-18T01:37:48.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>man 命令        查看一个命令的用法（q键退出）<br>文件管理命令                   //命令里输入部分后 可以按tab键可以进行自动补全，前提是只有一个<br> ls 查看目录                                             linux常见目录<br>    -a  查看所有文件 包括隐藏文件                 /        根目录<br>    -l   查看详细列表                         ~        代表当前用户的家目录<br>    -d  仅仅查看目录                         home        每个用户会在home目录下创建一个新的目录对应该用户的家目录<br>cd 切换目录<br>pwd 查看当前所在的路径<br>touch 文件名   触摸一个文件，存在就改变文件的最后访问时间，不存在就创建文件<br>mkdir 目录名   创建目录        -p  递归创建（可以同时创建多级目录） Eg：mkdir -p java/thread/test<br>cp 源文件 目标地址       拷贝文件或目录       -r   递归拷贝（拷贝文件夹）   Eg：cp -r 源目录 目标目录<br>rmdir 目录名称    删除空目录<br>rm 文件名               删除文件               rm -r 目录名       递归删除目录    -f   强制删除<br>mv 文件名           剪切文件或目录     mv  源文件或目录   目标位置    mv    原文件名   新文件名   重命名文件<br>cat 文件名   查看文件里面的内容   -n  查看内容并显示行号   cat -n |more 分页查看文件里面的内容并显示行号，按空格查看下一页，按回车查看下一行<br>tac 文件名   倒过来查看文件里面的内容<br>head -n（数字）文件名    查看文件前n行的内容<br>tail -n（数字）文件名    查看文件后n行的内容</p></blockquote><p>vi(vim)    文件名     编辑文件，若不存在则创建这个文件 三种模式：<br>1、命令模式    vi(vim)   文件名<br>nyy   n代表一个数值  默认为1，表示复制光标开始往下n行<br>p  粘贴<br>ndd   n代表一个数值  默认为1，表示删除光标开始往下n行<br>：set number   设置行号<br>：行号  让光标定位到指定行<br>2、输入模式 （在命令模式输入a,A,i,I,o  进入输入模式，按esc回到命令模式）<br>i（在当前光标位置的前面插入）I（返回当前行最前面进行输入）<br>a（在当前光标位置的后面插入）A（返回当前行最后面进行输入）<br>o（在下一行插入）<br>3、编辑模式（在命令模式输入：进入编辑模式，按esc回到命令模式）：q 退出  ：w  保存  ：！强制   ：q！强制退出  ：wq 保存退出</p><p>find -name 文件名       根据文件名查找   “<em>文件部分名*”（查找包含该部分文件名的文件）<br>       -iname  文件名     根据文件名查找（忽略大小写）<br>find 指定的路径 -name 文件名         查找路径下来所有该文件名的文件                    Eg: find /home/ -name test<br>find /home/ -name “</em>.log”  查找该后缀的文件（在home路径下）<br>find  -size [+(大于)或-(小于)]文件大小     根据文件大小进行查找（大小单位默认字节）                        Eg：find /home/ -size +1G    查找该路径下大于1g的文件    单位：c，k，M,G<br>       -atime       根据最近修改时间进行查找（天）<br>       -ctime<br>       -mtime<br>find /home/ -atime +5    查找5天前访问过的文件（-5则是5天之内）<br>逻辑运算查找：<br>    -a   and   逻辑与<br>    -o     or     逻辑或<br>    -not  非      取反                       Eg：find /home/ -name “<em>hello</em>” -a -size +1M   查找文件名中包含hello的以及大小大于1M的文件</p><p>reboot   重启</p><p>文件的压缩与解压缩<br>1、zip压缩文件命令<br>    zip 压缩包名  文件名                    同时压缩多个则在文件名后再加文件名<br>    zip  -r   压缩包名  目录名              压缩目录所有文件在同一压缩包中<br>    unzip 压缩包名                             解压缩在当前目录下<br>    unzip -d 指定一个目录 压缩包名        解压缩到指定一个目录下<br>2、gz压缩文件命令<br>    gzip 要压缩的文件名            生成压缩文件后，原文件会默认删除</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;man 命令        查看一个命令的用法（q键退出）&lt;br&gt;文件管理命令                   //命令里输入部分后 可以按tab键可以进行自动补全，前提是只有一个&lt;br&gt; ls 查看目录                    
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://Threee-hub.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 计算机系统概述 错题解析 二</title>
    <link href="http://Threee-hub.github.io/2019/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%94%99%E9%A2%9802/"/>
    <id>http://Threee-hub.github.io/2019/11/13/操作系统错题02/</id>
    <published>2019-11-13T11:03:14.000Z</published>
    <updated>2019-11-13T13:34:56.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统-——-计算机系统概述-错题解析-二"><a href="#操作系统-——-计算机系统概述-错题解析-二" class="headerlink" title="操作系统 —— 计算机系统概述 错题解析 二"></a>操作系统 —— 计算机系统概述 错题解析 二</h3><blockquote><p>选择题：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111301.png" alt="题目一"><br>答案为 C 。</p><ol><li>批处理的主要缺点是缺少<strong>交互性</strong></li><li>多道程序设计的提出是为了<strong>提高系统利用率和吞吐量</strong>。</li><li>I/O通道是实际上是一种特殊的<strong>处理器</strong>，它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。特点为：通道指令类型单一（局限于与I/O操作有关的指令）、通道没有自己的内存（通道执行的指令一般放在其主机的内存中）。</li></ol></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111302.png" alt="题目二"><br>答案为 A 。命令解释程序（如Shell）属于命令接口，在用户态执行。</p></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111303.png" alt="题目三"><br>答案为 B 。</p><ol><li>中断处理和子程序调用时，一定会保存PC（程序计数器）。</li><li>通用数据寄存器和通用地址寄存器在子程序调用时，若有数据更改则需要保存若无更改则不需要。</li><li>程序状态字寄存器（PSWR）: 运算器的一部分，其中某标志位<strong>标记了当前处理器状态（内核态 or 用户态）</strong>。中断处理程序结束时，需将处理器状态切换回原有状态（即修改PSWR标志位）。PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，如有无进位（CY位），有无溢出（OV位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（P位）等；另一类是存放控制信息，如允许中断(IF位)，跟踪标志（TF位）等。有些机器中将PSW称为标志寄存器FR（Flag Register）。</li></ol></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111304.png" alt="题目四"><br>答案为 C 。（看清题目是在用户态<strong>发生</strong>还是<strong>执行</strong>）<br>进程切换是发生在系统调用执行过程中的事件，因此只能发生在内核态。</p></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111305.png" alt="题目五"><br>答案为 C 。</p><ol><li>当要执行系统调用时，用户先传递系统调用参数给通用寄存器，再执行陷入（trap）指令进入内核态，从通用寄存器中得到数据执行相应的服务程序，执行结束后回到用户态。</li><li><strong>区分执行态的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态转换到用户态发生在中断返回用户系统时</strong>。</li><li><strong>陷入（trap）指令： 又称访管指令。系统调用时，该指令使处理机从用户态转为内核态</strong>。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统-——-计算机系统概述-错题解析-二&quot;&gt;&lt;a href=&quot;#操作系统-——-计算机系统概述-错题解析-二&quot; class=&quot;headerlink&quot; title=&quot;操作系统 —— 计算机系统概述 错题解析 二&quot;&gt;&lt;/a&gt;操作系统 —— 计算机系统概述 错题解析
      
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://Threee-hub.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 计算机系统概述 错题解析 一</title>
    <link href="http://Threee-hub.github.io/2019/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%94%99%E9%A2%9801/"/>
    <id>http://Threee-hub.github.io/2019/11/12/操作系统错题01/</id>
    <published>2019-11-12T15:41:37.000Z</published>
    <updated>2019-11-13T05:11:10.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统-——-计算机系统概述-错题解析-一"><a href="#操作系统-——-计算机系统概述-错题解析-一" class="headerlink" title="操作系统 —— 计算机系统概述 错题解析 一"></a>操作系统 —— 计算机系统概述 错题解析 一</h3><blockquote><p>应用题：计算CPU利用率。（利用<strong>甘特图</strong>求解）<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111202.jpg" alt="题目一"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/%E7%94%98%E7%89%B9%E5%9B%BE.jpg" alt="答案一"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111201.jpg" alt="答案二"></p><ul><li>绘制甘特图时，需注意<strong>打印设备、处理器</strong>是只能有一个程序使用而不能多个程序同时使用。</li><li>多道批处理系统的<strong>I/O设备</strong>可与<strong>CPU</strong>并行工作，这是借助于<strong>中断技术</strong> 实现的。</li></ul></blockquote><blockquote><hr></blockquote><blockquote><p>选择题：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111203.jpg" alt="题目二"></p><blockquote><ul><li>计算机开机后，操作系统最终被加载到RAM中。</li><li>裸机状态时，BIOS存在在ROM中，且只有ROM中有数据。</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111204.jpg" alt="题目三"></p><ul><li>操作系统接口分为三部分：</li></ul><ol><li>命令接口：用户利用这些操作命令来组织和控制作业的执行。方式有两种：联机控制方式和脱机控制方式。</li><li>程序接口（即系统调用）: 由一组系统调用命令组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。</li><li>图形接口：如GUI（图形用户界面），严格来说GUI图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。图形接口也是通过调用程序接口实现的。</li></ol><ul><li>Shell 是指“为使用者提供操作界面”的软件（即命令解析器），属于命令接口。它接收用户命令，然后调用相应的应用程序。</li><li>广义指令就是系统调用指令。而系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用。</li></ul></blockquote><blockquote><hr></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111205.jpg" alt="题目四"></p><blockquote><ul><li>多道程序的运行环境比单道程序更加复杂，但是多道程序时程序的执行就失去了封闭性和顺序性。并且因为<strong>共享</strong>资源及相互协同而产生了竞争，相互<strong>制约</strong>。多道程序设计的系统中允许多个程序进入内存，但为了公平性，各个程序是<strong>交替</strong>运行，当一道程序暂停时，CPU立即转去运行其他程序。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统-——-计算机系统概述-错题解析-一&quot;&gt;&lt;a href=&quot;#操作系统-——-计算机系统概述-错题解析-一&quot; class=&quot;headerlink&quot; title=&quot;操作系统 —— 计算机系统概述 错题解析 一&quot;&gt;&lt;/a&gt;操作系统 —— 计算机系统概述 错题解析
      
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://Threee-hub.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>子类调用构造函数时遇到的小问题</title>
    <link href="http://Threee-hub.github.io/2019/11/09/%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://Threee-hub.github.io/2019/11/09/子类构造方法/</id>
    <published>2019-11-09T12:54:27.000Z</published>
    <updated>2019-11-13T13:09:17.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="子类调用构造函数时遇到的小问题"><a href="#子类调用构造函数时遇到的小问题" class="headerlink" title="子类调用构造函数时遇到的小问题"></a>子类调用构造函数时遇到的小问题</h3><blockquote><p>当子类调用构造函数时，若未使用this()和super()，系统则会在子类构造函数时自动调用父类的无参构造函数（即自动补上super()）,因此若父类并未构造无参构造函数时，程序就会报错。</p></blockquote><pre><code>public class student extends person{    public student(String name, int age, char sex) {    }}class person {    private String name;    private int age;    private char sex;    public person(String name, int age, char sex) {        this.name = name;        this.age = age;        this.sex = sex;    }}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/1110%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE2.png" alt="错误信息01"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/1110%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png" alt="错误信息02"></p><blockquote><p>解决这个问题的方法如下：</p></blockquote><ul><li>在父类中添加无参构造方法 person(){}</li><li>在子类的构造方法中添加 super( name, age, sex )</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;子类调用构造函数时遇到的小问题&quot;&gt;&lt;a href=&quot;#子类调用构造函数时遇到的小问题&quot; class=&quot;headerlink&quot; title=&quot;子类调用构造函数时遇到的小问题&quot;&gt;&lt;/a&gt;子类调用构造函数时遇到的小问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当子类调用
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://Threee-hub.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>静态属性、代码块的执行顺序</title>
    <link href="http://Threee-hub.github.io/2019/11/08/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://Threee-hub.github.io/2019/11/08/代码块/</id>
    <published>2019-11-08T04:47:47.191Z</published>
    <updated>2019-11-08T12:19:16.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态属性、静态代码块以及构造代码块的执行先后顺序"><a href="#静态属性、静态代码块以及构造代码块的执行先后顺序" class="headerlink" title="静态属性、静态代码块以及构造代码块的执行先后顺序"></a>静态属性、静态代码块以及构造代码块的执行先后顺序</h2><blockquote><p>最近遇到一道Java先后调用的题（下图），程序中输出A.x和B.y的值。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="代码块"></p><blockquote><p>如图，输出1，2。       那么是为什么呢<br>从主函数开始，载入A类，A类具有静态属性和静态代码块，而静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，所以x被赋初值为0<br>再执行静态代码块，此时调用B类，静态属性y并未赋值而是被JVM赋了初值0，因此此时x=1，y=0.并输出“静态代码块被调用”<br>下一步主函数创建了A类的对象，构造代码块被调用并输出，下一步输出B.y，y被赋值 y=A.x + 1 = 1+1=2.  最后输出1和2.</p></blockquote><h5 id="因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦"><a href="#因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦" class="headerlink" title="因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦~"></a>因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦~</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;静态属性、静态代码块以及构造代码块的执行先后顺序&quot;&gt;&lt;a href=&quot;#静态属性、静态代码块以及构造代码块的执行先后顺序&quot; class=&quot;headerlink&quot; title=&quot;静态属性、静态代码块以及构造代码块的执行先后顺序&quot;&gt;&lt;/a&gt;静态属性、静态代码块以及构造
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://Threee-hub.github.io/tags/Java/"/>
    
      <category term="静态属性" scheme="http://Threee-hub.github.io/tags/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7/"/>
    
      <category term="静态代码块" scheme="http://Threee-hub.github.io/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
</feed>
