<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘山的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Threee-hub.github.io/"/>
  <updated>2019-11-27T03:41:09.933Z</updated>
  <id>http://Threee-hub.github.io/</id>
  
  <author>
    <name>刘山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一</title>
    <link href="http://Threee-hub.github.io/2019/11/26/%E7%BB%84%E5%8E%9F%E9%94%99%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://Threee-hub.github.io/2019/11/26/组原错题知识点/</id>
    <published>2019-11-26T15:35:58.000Z</published>
    <updated>2019-11-27T03:41:09.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成原理-计算机系统概述-错题解析-知识点-一"><a href="#计算机组成原理-计算机系统概述-错题解析-知识点-一" class="headerlink" title="计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一"></a>计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一</h3><h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><blockquote><ol><li>早期的冯·诺依曼机以<strong>运算器</strong>为中心，而现代计算机以<strong>存储器</strong>为中心。冯·诺依曼机最根本的特征是采用<strong>“存储程序”</strong>原理，基本工作方式是<strong>控制流驱动方式</strong>。</li><li><strong>“存储程序”原理</strong>，是将根据特定问题编写的程序存放在计算机存储器中，然后按存储器中的存储程序的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令，直至程序结束执行。</li></ol></blockquote><blockquote><hr></blockquote><h4 id="错题解析："><a href="#错题解析：" class="headerlink" title="错题解析："></a>错题解析：</h4><p>习题一：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112601.png" alt="题目一"></p><blockquote><ol><li>答案为 C 。</li><li>计算机可以从时间和空间两方面来区分指令和数据。在时间上，<strong>取指周期(取指令)</strong>从内存中取出的是指令，而<strong>执行周期（执行指令）</strong>从内存取出或往内存中写入的是数据；在空间上，从内存中取出指令送<strong>控制器</strong>，而执行周期从内存从取的数据送<strong>运算器</strong>、往内存写入的数据也是来自于运算器。</li></ol></blockquote><blockquote><hr><p>习题二：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112602.png" alt="题目二"></p><ol><li>答案为 C 。</li><li>基本原理：把存储单元所存内容的某一部分作为检索项（即关键字项），去检索该存储器。</li><li>计算机系统中，相联存储器主要用于虚拟存储器中存放段表、页表和快表，以及高速缓冲存储器Cache中存放块地址。这是因为，在这两种应用中，都需要快速查找。</li></ol></blockquote><blockquote><hr></blockquote><p>习题三：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112603.png" alt="题目三"></p><blockquote><ol><li>答案为 C 。</li><li>翻译程序是指把高级语言源程序转换成机器语言程序（目标代码）的软件。主要有两种：一种是<strong>编译程序</strong>，它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无需重新编译。另一种是<strong>解释程序</strong>，它将源程序的一条语句翻译成对应的机器目标代码并立即执行，然后翻译下一条源程序语句并执行，直至全部源程序语句被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</li><li>汇编语言也是一种语言翻译程序，是面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。<br>如C语言编译链接过程：源程序（.C）–（C编译器）–&gt; 汇编源程序 –（汇编程序）–&gt; 目标程序 –（链接程序）–&gt; 可执行程序</li></ol></blockquote><blockquote><hr></blockquote><p>习题四：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/112604.png" alt="题目四"></p><blockquote><p>· 答案为 C 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成原理-计算机系统概述-错题解析-知识点-一&quot;&gt;&lt;a href=&quot;#计算机组成原理-计算机系统概述-错题解析-知识点-一&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理 - 计算机系统概述 错题解析 + 知识点 一&quot;&gt;&lt;/a&gt;计算机组
      
    
    </summary>
    
    
    
      <category term="计算机组成原理" scheme="http://Threee-hub.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 计算机系统概述 错题解析 二</title>
    <link href="http://Threee-hub.github.io/2019/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%94%99%E9%A2%9802/"/>
    <id>http://Threee-hub.github.io/2019/11/13/操作系统错题02/</id>
    <published>2019-11-13T11:03:14.000Z</published>
    <updated>2019-11-13T13:34:56.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统-——-计算机系统概述-错题解析-二"><a href="#操作系统-——-计算机系统概述-错题解析-二" class="headerlink" title="操作系统 —— 计算机系统概述 错题解析 二"></a>操作系统 —— 计算机系统概述 错题解析 二</h3><blockquote><p>选择题：<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111301.png" alt="题目一"><br>答案为 C 。</p><ol><li>批处理的主要缺点是缺少<strong>交互性</strong></li><li>多道程序设计的提出是为了<strong>提高系统利用率和吞吐量</strong>。</li><li>I/O通道是实际上是一种特殊的<strong>处理器</strong>，它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。特点为：通道指令类型单一（局限于与I/O操作有关的指令）、通道没有自己的内存（通道执行的指令一般放在其主机的内存中）。</li></ol></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111302.png" alt="题目二"><br>答案为 A 。命令解释程序（如Shell）属于命令接口，在用户态执行。</p></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111303.png" alt="题目三"><br>答案为 B 。</p><ol><li>中断处理和子程序调用时，一定会保存PC（程序计数器）。</li><li>通用数据寄存器和通用地址寄存器在子程序调用时，若有数据更改则需要保存若无更改则不需要。</li><li>程序状态字寄存器（PSWR）: 运算器的一部分，其中某标志位<strong>标记了当前处理器状态（内核态 or 用户态）</strong>。中断处理程序结束时，需将处理器状态切换回原有状态（即修改PSWR标志位）。PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，如有无进位（CY位），有无溢出（OV位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（P位）等；另一类是存放控制信息，如允许中断(IF位)，跟踪标志（TF位）等。有些机器中将PSW称为标志寄存器FR（Flag Register）。</li></ol></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111304.png" alt="题目四"><br>答案为 C 。（看清题目是在用户态<strong>发生</strong>还是<strong>执行</strong>）<br>进程切换是发生在系统调用执行过程中的事件，因此只能发生在内核态。</p></blockquote><blockquote><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111305.png" alt="题目五"><br>答案为 C 。</p><ol><li>当要执行系统调用时，用户先传递系统调用参数给通用寄存器，再执行陷入（trap）指令进入内核态，从通用寄存器中得到数据执行相应的服务程序，执行结束后回到用户态。</li><li><strong>区分执行态的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态转换到用户态发生在中断返回用户系统时</strong>。</li><li><strong>陷入（trap）指令： 又称访管指令。系统调用时，该指令使处理机从用户态转为内核态</strong>。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统-——-计算机系统概述-错题解析-二&quot;&gt;&lt;a href=&quot;#操作系统-——-计算机系统概述-错题解析-二&quot; class=&quot;headerlink&quot; title=&quot;操作系统 —— 计算机系统概述 错题解析 二&quot;&gt;&lt;/a&gt;操作系统 —— 计算机系统概述 错题解析
      
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://Threee-hub.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 计算机系统概述 错题解析 一</title>
    <link href="http://Threee-hub.github.io/2019/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%94%99%E9%A2%9801/"/>
    <id>http://Threee-hub.github.io/2019/11/12/操作系统错题01/</id>
    <published>2019-11-12T15:41:37.000Z</published>
    <updated>2019-11-13T05:11:10.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统-——-计算机系统概述-错题解析-一"><a href="#操作系统-——-计算机系统概述-错题解析-一" class="headerlink" title="操作系统 —— 计算机系统概述 错题解析 一"></a>操作系统 —— 计算机系统概述 错题解析 一</h3><blockquote><p>应用题：计算CPU利用率。（利用<strong>甘特图</strong>求解）<br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111202.jpg" alt="题目一"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/%E7%94%98%E7%89%B9%E5%9B%BE.jpg" alt="答案一"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111201.jpg" alt="答案二"></p><ul><li>绘制甘特图时，需注意<strong>打印设备、处理器</strong>是只能有一个程序使用而不能多个程序同时使用。</li><li>多道批处理系统的<strong>I/O设备</strong>可与<strong>CPU</strong>并行工作，这是借助于<strong>中断技术</strong> 实现的。</li></ul></blockquote><blockquote><hr></blockquote><blockquote><p>选择题：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111203.jpg" alt="题目二"></p><blockquote><ul><li>计算机开机后，操作系统最终被加载到RAM中。</li><li>裸机状态时，BIOS存在在ROM中，且只有ROM中有数据。</li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111204.jpg" alt="题目三"></p><ul><li>操作系统接口分为三部分：</li></ul><ol><li>命令接口：用户利用这些操作命令来组织和控制作业的执行。方式有两种：联机控制方式和脱机控制方式。</li><li>程序接口（即系统调用）: 由一组系统调用命令组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。</li><li>图形接口：如GUI（图形用户界面），严格来说GUI图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。图形接口也是通过调用程序接口实现的。</li></ol><ul><li>Shell 是指“为使用者提供操作界面”的软件（即命令解析器），属于命令接口。它接收用户命令，然后调用相应的应用程序。</li><li>广义指令就是系统调用指令。而系统中的缓存全部由操作系统管理，对用户是透明的，操作系统不提供管理系统缓存的系统调用。</li></ul></blockquote><blockquote><hr></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/codesrc/111205.jpg" alt="题目四"></p><blockquote><ul><li>多道程序的运行环境比单道程序更加复杂，但是多道程序时程序的执行就失去了封闭性和顺序性。并且因为<strong>共享</strong>资源及相互协同而产生了竞争，相互<strong>制约</strong>。多道程序设计的系统中允许多个程序进入内存，但为了公平性，各个程序是<strong>交替</strong>运行，当一道程序暂停时，CPU立即转去运行其他程序。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统-——-计算机系统概述-错题解析-一&quot;&gt;&lt;a href=&quot;#操作系统-——-计算机系统概述-错题解析-一&quot; class=&quot;headerlink&quot; title=&quot;操作系统 —— 计算机系统概述 错题解析 一&quot;&gt;&lt;/a&gt;操作系统 —— 计算机系统概述 错题解析
      
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://Threee-hub.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>子类调用构造函数时遇到的小问题</title>
    <link href="http://Threee-hub.github.io/2019/11/09/%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://Threee-hub.github.io/2019/11/09/子类构造方法/</id>
    <published>2019-11-09T12:54:27.000Z</published>
    <updated>2019-11-13T13:09:17.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="子类调用构造函数时遇到的小问题"><a href="#子类调用构造函数时遇到的小问题" class="headerlink" title="子类调用构造函数时遇到的小问题"></a>子类调用构造函数时遇到的小问题</h3><blockquote><p>当子类调用构造函数时，若未使用this()和super()，系统则会在子类构造函数时自动调用父类的无参构造函数（即自动补上super()）,因此若父类并未构造无参构造函数时，程序就会报错。</p></blockquote><pre><code>public class student extends person{    public student(String name, int age, char sex) {    }}class person {    private String name;    private int age;    private char sex;    public person(String name, int age, char sex) {        this.name = name;        this.age = age;        this.sex = sex;    }}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/1110%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE2.png" alt="错误信息01"><br><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/1110%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png" alt="错误信息02"></p><blockquote><p>解决这个问题的方法如下：</p></blockquote><ul><li>在父类中添加无参构造方法 person(){}</li><li>在子类的构造方法中添加 super( name, age, sex )</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;子类调用构造函数时遇到的小问题&quot;&gt;&lt;a href=&quot;#子类调用构造函数时遇到的小问题&quot; class=&quot;headerlink&quot; title=&quot;子类调用构造函数时遇到的小问题&quot;&gt;&lt;/a&gt;子类调用构造函数时遇到的小问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当子类调用
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://Threee-hub.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>静态属性、代码块的执行顺序</title>
    <link href="http://Threee-hub.github.io/2019/11/08/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://Threee-hub.github.io/2019/11/08/代码块/</id>
    <published>2019-11-08T04:47:47.191Z</published>
    <updated>2019-11-08T12:19:16.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态属性、静态代码块以及构造代码块的执行先后顺序"><a href="#静态属性、静态代码块以及构造代码块的执行先后顺序" class="headerlink" title="静态属性、静态代码块以及构造代码块的执行先后顺序"></a>静态属性、静态代码块以及构造代码块的执行先后顺序</h2><blockquote><p>最近遇到一道Java先后调用的题（下图），程序中输出A.x和B.y的值。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/threee-hub/img@master/%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="代码块"></p><blockquote><p>如图，输出1，2。       那么是为什么呢<br>从主函数开始，载入A类，A类具有静态属性和静态代码块，而静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，所以x被赋初值为0<br>再执行静态代码块，此时调用B类，静态属性y并未赋值而是被JVM赋了初值0，因此此时x=1，y=0.并输出“静态代码块被调用”<br>下一步主函数创建了A类的对象，构造代码块被调用并输出，下一步输出B.y，y被赋值 y=A.x + 1 = 1+1=2.  最后输出1和2.</p></blockquote><h5 id="因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦"><a href="#因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦" class="headerlink" title="因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦~"></a>因此我们可以得出结果，静态属性和静态代码块是按顺序执行，哪个在前面就先执行哪个，而构造代码块是当类对象实例化时（new时）被调用。这题还有一个知识点就是类的生命周期，下次再学习分享一下哦~</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;静态属性、静态代码块以及构造代码块的执行先后顺序&quot;&gt;&lt;a href=&quot;#静态属性、静态代码块以及构造代码块的执行先后顺序&quot; class=&quot;headerlink&quot; title=&quot;静态属性、静态代码块以及构造代码块的执行先后顺序&quot;&gt;&lt;/a&gt;静态属性、静态代码块以及构造
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://Threee-hub.github.io/tags/Java/"/>
    
      <category term="静态属性" scheme="http://Threee-hub.github.io/tags/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7/"/>
    
      <category term="静态代码块" scheme="http://Threee-hub.github.io/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
</feed>
